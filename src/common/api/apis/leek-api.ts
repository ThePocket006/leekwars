/* tslint:disable */
/* eslint-disable */
/**
 * Leekwars API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import type {AxiosResponse, AxiosInstance, AxiosRequestConfig} from "axios";
import globalAxios from "axios";
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
/**
 * LeekApi - axios parameter creator
 * @export
 */
export const LeekApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary leek - add-chip
         * @param {number} leekId 
         * @param {number} chipId 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekAddChipPost: async (leekId: number, chipId: number, body?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekAddChipPost.');
            }
            // verify required parameter 'chipId' is not null or undefined
            if (chipId === null || chipId === undefined) {
                throw new RequiredError('chipId','Required parameter chipId was null or undefined when calling leekAddChipPost.');
            }
            const localVarPath = `/leek/add-chip`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            if (chipId !== undefined) {
                localVarQueryParameter['chip_id'] = chipId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - add-weapon
         * @param {number} leekId 
         * @param {number} weaponId 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekAddWeaponPost: async (leekId: number, weaponId: number, body?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekAddWeaponPost.');
            }
            // verify required parameter 'weaponId' is not null or undefined
            if (weaponId === null || weaponId === undefined) {
                throw new RequiredError('weaponId','Required parameter weaponId was null or undefined when calling leekAddWeaponPost.');
            }
            const localVarPath = `/leek/add-weapon`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            if (weaponId !== undefined) {
                localVarQueryParameter['weapon_id'] = weaponId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - create
         * @param {string} name 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekCreatePost: async (name: string, body?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling leekCreatePost.');
            }
            const localVarPath = `/leek/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - delete-register
         * @param {number} leekId 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekDeleteRegisterDelete: async (leekId: number, key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekDeleteRegisterDelete.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling leekDeleteRegisterDelete.');
            }
            const localVarPath = `/leek/delete-register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - get-count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekGetCountGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/leek/get-count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - get
         * @param {number} leekId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekGetGet: async (leekId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekGetGet.');
            }
            const localVarPath = `/leek/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - get-next-price
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekGetNextPriceGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/leek/get-next-price`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - get-private
         * @param {number} leekId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekGetPrivateGet: async (leekId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekGetPrivateGet.');
            }
            const localVarPath = `/leek/get-private`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - get-registers
         * @param {number} leekId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekGetRegistersGet: async (leekId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekGetRegistersGet.');
            }
            const localVarPath = `/leek/get-registers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - register-auto-br
         * @param {number} leekId 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekRegisterAutoBrPost: async (leekId: number, body?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekRegisterAutoBrPost.');
            }
            const localVarPath = `/leek/register-auto-br`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - register-tournament
         * @param {number} leekId 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekRegisterTournamentPost: async (leekId: number, body?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekRegisterTournamentPost.');
            }
            const localVarPath = `/leek/register-tournament`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - remove-ai
         * @param {number} leekId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekRemoveAiDelete: async (leekId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekRemoveAiDelete.');
            }
            const localVarPath = `/leek/remove-ai`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - remove-chip
         * @param {number} chipId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekRemoveChipDelete: async (chipId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chipId' is not null or undefined
            if (chipId === null || chipId === undefined) {
                throw new RequiredError('chipId','Required parameter chipId was null or undefined when calling leekRemoveChipDelete.');
            }
            const localVarPath = `/leek/remove-chip`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (chipId !== undefined) {
                localVarQueryParameter['chip_id'] = chipId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - remove-hat
         * @param {number} leekId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekRemoveHatDelete: async (leekId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekRemoveHatDelete.');
            }
            const localVarPath = `/leek/remove-hat`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - remove-weapon
         * @param {number} weaponId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekRemoveWeaponDelete: async (weaponId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'weaponId' is not null or undefined
            if (weaponId === null || weaponId === undefined) {
                throw new RequiredError('weaponId','Required parameter weaponId was null or undefined when calling leekRemoveWeaponDelete.');
            }
            const localVarPath = `/leek/remove-weapon`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (weaponId !== undefined) {
                localVarQueryParameter['weapon_id'] = weaponId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - rename-crystals
         * @param {number} leekId 
         * @param {string} newName 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekRenameCrystalsPost: async (leekId: number, newName: string, body?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekRenameCrystalsPost.');
            }
            // verify required parameter 'newName' is not null or undefined
            if (newName === null || newName === undefined) {
                throw new RequiredError('newName','Required parameter newName was null or undefined when calling leekRenameCrystalsPost.');
            }
            const localVarPath = `/leek/rename-crystals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            if (newName !== undefined) {
                localVarQueryParameter['new_name'] = newName;
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - rename-habs
         * @param {number} leekId 
         * @param {string} newName 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekRenameHabsPost: async (leekId: number, newName: string, body?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekRenameHabsPost.');
            }
            // verify required parameter 'newName' is not null or undefined
            if (newName === null || newName === undefined) {
                throw new RequiredError('newName','Required parameter newName was null or undefined when calling leekRenameHabsPost.');
            }
            const localVarPath = `/leek/rename-habs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            if (newName !== undefined) {
                localVarQueryParameter['new_name'] = newName;
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - rich-tooltip
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekRichTooltipGet: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling leekRichTooltipGet.');
            }
            const localVarPath = `/leek/rich-tooltip`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - set-ai
         * @param {number} leekId 
         * @param {number} aiId 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekSetAiPost: async (leekId: number, aiId: number, body?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekSetAiPost.');
            }
            // verify required parameter 'aiId' is not null or undefined
            if (aiId === null || aiId === undefined) {
                throw new RequiredError('aiId','Required parameter aiId was null or undefined when calling leekSetAiPost.');
            }
            const localVarPath = `/leek/set-ai`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            if (aiId !== undefined) {
                localVarQueryParameter['ai_id'] = aiId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - set-face
         * @param {number} leekId 
         * @param {number} face 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekSetFacePut: async (leekId: number, face: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekSetFacePut.');
            }
            // verify required parameter 'face' is not null or undefined
            if (face === null || face === undefined) {
                throw new RequiredError('face','Required parameter face was null or undefined when calling leekSetFacePut.');
            }
            const localVarPath = `/leek/set-face`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            if (face !== undefined) {
                localVarQueryParameter['face'] = face;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - set-hat
         * @param {number} leekId 
         * @param {number} hatId 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekSetHatPost: async (leekId: number, hatId: number, body?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekSetHatPost.');
            }
            // verify required parameter 'hatId' is not null or undefined
            if (hatId === null || hatId === undefined) {
                throw new RequiredError('hatId','Required parameter hatId was null or undefined when calling leekSetHatPost.');
            }
            const localVarPath = `/leek/set-hat`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            if (hatId !== undefined) {
                localVarQueryParameter['hat_id'] = hatId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - set-in-garden
         * @param {number} leekId 
         * @param {boolean} inGarden 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekSetInGardenPost: async (leekId: number, inGarden: boolean, body?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekSetInGardenPost.');
            }
            // verify required parameter 'inGarden' is not null or undefined
            if (inGarden === null || inGarden === undefined) {
                throw new RequiredError('inGarden','Required parameter inGarden was null or undefined when calling leekSetInGardenPost.');
            }
            const localVarPath = `/leek/set-in-garden`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            if (inGarden !== undefined) {
                localVarQueryParameter['in_garden'] = inGarden;
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - set-metal
         * @param {number} leekId 
         * @param {boolean} metal 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekSetMetalPut: async (leekId: number, metal: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekSetMetalPut.');
            }
            // verify required parameter 'metal' is not null or undefined
            if (metal === null || metal === undefined) {
                throw new RequiredError('metal','Required parameter metal was null or undefined when calling leekSetMetalPut.');
            }
            const localVarPath = `/leek/set-metal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            if (metal !== undefined) {
                localVarQueryParameter['metal'] = metal;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - set-register
         * @param {number} leekId 
         * @param {string} key 
         * @param {string} value 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekSetRegisterPost: async (leekId: number, key: string, value: string, body?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekSetRegisterPost.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling leekSetRegisterPost.');
            }
            // verify required parameter 'value' is not null or undefined
            if (value === null || value === undefined) {
                throw new RequiredError('value','Required parameter value was null or undefined when calling leekSetRegisterPost.');
            }
            const localVarPath = `/leek/set-register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - set-weapon
         * @param {number} leekId 
         * @param {number} weapon 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekSetWeaponPut: async (leekId: number, weapon: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekSetWeaponPut.');
            }
            // verify required parameter 'weapon' is not null or undefined
            if (weapon === null || weapon === undefined) {
                throw new RequiredError('weapon','Required parameter weapon was null or undefined when calling leekSetWeaponPut.');
            }
            const localVarPath = `/leek/set-weapon`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            if (weapon !== undefined) {
                localVarQueryParameter['weapon'] = weapon;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - set-xp-blocked
         * @param {number} leekId 
         * @param {boolean} xpBlocked 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekSetXpBlockedPut: async (leekId: number, xpBlocked: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekSetXpBlockedPut.');
            }
            // verify required parameter 'xpBlocked' is not null or undefined
            if (xpBlocked === null || xpBlocked === undefined) {
                throw new RequiredError('xpBlocked','Required parameter xpBlocked was null or undefined when calling leekSetXpBlockedPut.');
            }
            const localVarPath = `/leek/set-xp-blocked`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            if (xpBlocked !== undefined) {
                localVarQueryParameter['xp_blocked'] = xpBlocked;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - spend-capital
         * @param {number} leekId 
         * @param {string} characteristics 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekSpendCapitalPost: async (leekId: number, characteristics: string, body?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekSpendCapitalPost.');
            }
            // verify required parameter 'characteristics' is not null or undefined
            if (characteristics === null || characteristics === undefined) {
                throw new RequiredError('characteristics','Required parameter characteristics was null or undefined when calling leekSpendCapitalPost.');
            }
            const localVarPath = `/leek/spend-capital`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            if (characteristics !== undefined) {
                localVarQueryParameter['characteristics'] = characteristics;
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - unregister-auto-br
         * @param {number} leekId 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekUnregisterAutoBrPost: async (leekId: number, body?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekUnregisterAutoBrPost.');
            }
            const localVarPath = `/leek/unregister-auto-br`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - unregister-tournament
         * @param {number} leekId 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekUnregisterTournamentPost: async (leekId: number, body?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekUnregisterTournamentPost.');
            }
            const localVarPath = `/leek/unregister-tournament`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - use-potion
         * @param {number} leekId 
         * @param {number} potionId 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekUsePotionPost: async (leekId: number, potionId: number, body?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekUsePotionPost.');
            }
            // verify required parameter 'potionId' is not null or undefined
            if (potionId === null || potionId === undefined) {
                throw new RequiredError('potionId','Required parameter potionId was null or undefined when calling leekUsePotionPost.');
            }
            const localVarPath = `/leek/use-potion`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            if (potionId !== undefined) {
                localVarQueryParameter['potion_id'] = potionId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LeekApi - functional programming interface
 * @export
 */
export const LeekApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary leek - add-chip
         * @param {number} leekId 
         * @param {number} chipId 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekAddChipPost(leekId: number, chipId: number, body?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekAddChipPost(leekId, chipId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - add-weapon
         * @param {number} leekId 
         * @param {number} weaponId 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekAddWeaponPost(leekId: number, weaponId: number, body?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekAddWeaponPost(leekId, weaponId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - create
         * @param {string} name 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekCreatePost(name: string, body?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekCreatePost(name, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - delete-register
         * @param {number} leekId 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekDeleteRegisterDelete(leekId: number, key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekDeleteRegisterDelete(leekId, key, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - get-count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekGetCountGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekGetCountGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - get
         * @param {number} leekId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekGetGet(leekId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekGetGet(leekId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - get-next-price
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekGetNextPriceGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekGetNextPriceGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - get-private
         * @param {number} leekId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekGetPrivateGet(leekId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekGetPrivateGet(leekId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - get-registers
         * @param {number} leekId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekGetRegistersGet(leekId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekGetRegistersGet(leekId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - register-auto-br
         * @param {number} leekId 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekRegisterAutoBrPost(leekId: number, body?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekRegisterAutoBrPost(leekId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - register-tournament
         * @param {number} leekId 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekRegisterTournamentPost(leekId: number, body?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekRegisterTournamentPost(leekId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - remove-ai
         * @param {number} leekId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekRemoveAiDelete(leekId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekRemoveAiDelete(leekId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - remove-chip
         * @param {number} chipId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekRemoveChipDelete(chipId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekRemoveChipDelete(chipId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - remove-hat
         * @param {number} leekId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekRemoveHatDelete(leekId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekRemoveHatDelete(leekId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - remove-weapon
         * @param {number} weaponId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekRemoveWeaponDelete(weaponId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekRemoveWeaponDelete(weaponId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - rename-crystals
         * @param {number} leekId 
         * @param {string} newName 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekRenameCrystalsPost(leekId: number, newName: string, body?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekRenameCrystalsPost(leekId, newName, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - rename-habs
         * @param {number} leekId 
         * @param {string} newName 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekRenameHabsPost(leekId: number, newName: string, body?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekRenameHabsPost(leekId, newName, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - rich-tooltip
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekRichTooltipGet(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekRichTooltipGet(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - set-ai
         * @param {number} leekId 
         * @param {number} aiId 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekSetAiPost(leekId: number, aiId: number, body?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekSetAiPost(leekId, aiId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - set-face
         * @param {number} leekId 
         * @param {number} face 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekSetFacePut(leekId: number, face: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekSetFacePut(leekId, face, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - set-hat
         * @param {number} leekId 
         * @param {number} hatId 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekSetHatPost(leekId: number, hatId: number, body?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekSetHatPost(leekId, hatId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - set-in-garden
         * @param {number} leekId 
         * @param {boolean} inGarden 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekSetInGardenPost(leekId: number, inGarden: boolean, body?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekSetInGardenPost(leekId, inGarden, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - set-metal
         * @param {number} leekId 
         * @param {boolean} metal 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekSetMetalPut(leekId: number, metal: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekSetMetalPut(leekId, metal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - set-register
         * @param {number} leekId 
         * @param {string} key 
         * @param {string} value 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekSetRegisterPost(leekId: number, key: string, value: string, body?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekSetRegisterPost(leekId, key, value, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - set-weapon
         * @param {number} leekId 
         * @param {number} weapon 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekSetWeaponPut(leekId: number, weapon: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekSetWeaponPut(leekId, weapon, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - set-xp-blocked
         * @param {number} leekId 
         * @param {boolean} xpBlocked 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekSetXpBlockedPut(leekId: number, xpBlocked: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekSetXpBlockedPut(leekId, xpBlocked, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - spend-capital
         * @param {number} leekId 
         * @param {string} characteristics 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekSpendCapitalPost(leekId: number, characteristics: string, body?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekSpendCapitalPost(leekId, characteristics, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - unregister-auto-br
         * @param {number} leekId 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekUnregisterAutoBrPost(leekId: number, body?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekUnregisterAutoBrPost(leekId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - unregister-tournament
         * @param {number} leekId 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekUnregisterTournamentPost(leekId: number, body?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekUnregisterTournamentPost(leekId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - use-potion
         * @param {number} leekId 
         * @param {number} potionId 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekUsePotionPost(leekId: number, potionId: number, body?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekUsePotionPost(leekId, potionId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LeekApi - factory interface
 * @export
 */
export const LeekApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary leek - add-chip
         * @param {number} leekId 
         * @param {number} chipId 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekAddChipPost(leekId: number, chipId: number, body?: any, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return LeekApiFp(configuration).leekAddChipPost(leekId, chipId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - add-weapon
         * @param {number} leekId 
         * @param {number} weaponId 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekAddWeaponPost(leekId: number, weaponId: number, body?: any, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return LeekApiFp(configuration).leekAddWeaponPost(leekId, weaponId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - create
         * @param {string} name 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekCreatePost(name: string, body?: any, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return LeekApiFp(configuration).leekCreatePost(name, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - delete-register
         * @param {number} leekId 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekDeleteRegisterDelete(leekId: number, key: string, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return LeekApiFp(configuration).leekDeleteRegisterDelete(leekId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - get-count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekGetCountGet(options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return LeekApiFp(configuration).leekGetCountGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - get
         * @param {number} leekId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekGetGet(leekId: number, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return LeekApiFp(configuration).leekGetGet(leekId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - get-next-price
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekGetNextPriceGet(options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return LeekApiFp(configuration).leekGetNextPriceGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - get-private
         * @param {number} leekId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekGetPrivateGet(leekId: number, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return LeekApiFp(configuration).leekGetPrivateGet(leekId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - get-registers
         * @param {number} leekId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekGetRegistersGet(leekId: number, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return LeekApiFp(configuration).leekGetRegistersGet(leekId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - register-auto-br
         * @param {number} leekId 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekRegisterAutoBrPost(leekId: number, body?: any, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return LeekApiFp(configuration).leekRegisterAutoBrPost(leekId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - register-tournament
         * @param {number} leekId 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekRegisterTournamentPost(leekId: number, body?: any, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return LeekApiFp(configuration).leekRegisterTournamentPost(leekId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - remove-ai
         * @param {number} leekId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekRemoveAiDelete(leekId: number, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return LeekApiFp(configuration).leekRemoveAiDelete(leekId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - remove-chip
         * @param {number} chipId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekRemoveChipDelete(chipId: number, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return LeekApiFp(configuration).leekRemoveChipDelete(chipId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - remove-hat
         * @param {number} leekId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekRemoveHatDelete(leekId: number, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return LeekApiFp(configuration).leekRemoveHatDelete(leekId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - remove-weapon
         * @param {number} weaponId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekRemoveWeaponDelete(weaponId: number, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return LeekApiFp(configuration).leekRemoveWeaponDelete(weaponId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - rename-crystals
         * @param {number} leekId 
         * @param {string} newName 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekRenameCrystalsPost(leekId: number, newName: string, body?: any, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return LeekApiFp(configuration).leekRenameCrystalsPost(leekId, newName, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - rename-habs
         * @param {number} leekId 
         * @param {string} newName 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekRenameHabsPost(leekId: number, newName: string, body?: any, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return LeekApiFp(configuration).leekRenameHabsPost(leekId, newName, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - rich-tooltip
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekRichTooltipGet(id: number, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return LeekApiFp(configuration).leekRichTooltipGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - set-ai
         * @param {number} leekId 
         * @param {number} aiId 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekSetAiPost(leekId: number, aiId: number, body?: any, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return LeekApiFp(configuration).leekSetAiPost(leekId, aiId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - set-face
         * @param {number} leekId 
         * @param {number} face 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekSetFacePut(leekId: number, face: number, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return LeekApiFp(configuration).leekSetFacePut(leekId, face, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - set-hat
         * @param {number} leekId 
         * @param {number} hatId 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekSetHatPost(leekId: number, hatId: number, body?: any, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return LeekApiFp(configuration).leekSetHatPost(leekId, hatId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - set-in-garden
         * @param {number} leekId 
         * @param {boolean} inGarden 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekSetInGardenPost(leekId: number, inGarden: boolean, body?: any, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return LeekApiFp(configuration).leekSetInGardenPost(leekId, inGarden, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - set-metal
         * @param {number} leekId 
         * @param {boolean} metal 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekSetMetalPut(leekId: number, metal: boolean, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return LeekApiFp(configuration).leekSetMetalPut(leekId, metal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - set-register
         * @param {number} leekId 
         * @param {string} key 
         * @param {string} value 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekSetRegisterPost(leekId: number, key: string, value: string, body?: any, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return LeekApiFp(configuration).leekSetRegisterPost(leekId, key, value, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - set-weapon
         * @param {number} leekId 
         * @param {number} weapon 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekSetWeaponPut(leekId: number, weapon: number, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return LeekApiFp(configuration).leekSetWeaponPut(leekId, weapon, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - set-xp-blocked
         * @param {number} leekId 
         * @param {boolean} xpBlocked 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekSetXpBlockedPut(leekId: number, xpBlocked: boolean, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return LeekApiFp(configuration).leekSetXpBlockedPut(leekId, xpBlocked, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - spend-capital
         * @param {number} leekId 
         * @param {string} characteristics 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekSpendCapitalPost(leekId: number, characteristics: string, body?: any, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return LeekApiFp(configuration).leekSpendCapitalPost(leekId, characteristics, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - unregister-auto-br
         * @param {number} leekId 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekUnregisterAutoBrPost(leekId: number, body?: any, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return LeekApiFp(configuration).leekUnregisterAutoBrPost(leekId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - unregister-tournament
         * @param {number} leekId 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekUnregisterTournamentPost(leekId: number, body?: any, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return LeekApiFp(configuration).leekUnregisterTournamentPost(leekId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - use-potion
         * @param {number} leekId 
         * @param {number} potionId 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekUsePotionPost(leekId: number, potionId: number, body?: any, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return LeekApiFp(configuration).leekUsePotionPost(leekId, potionId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LeekApi - object-oriented interface
 * @export
 * @class LeekApi
 * @extends {BaseAPI}
 */
export class LeekApi extends BaseAPI {
    /**
     * 
     * @summary leek - add-chip
     * @param {number} leekId 
     * @param {number} chipId 
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekAddChipPost(leekId: number, chipId: number, body?: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return LeekApiFp(this.configuration).leekAddChipPost(leekId, chipId, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - add-weapon
     * @param {number} leekId 
     * @param {number} weaponId 
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekAddWeaponPost(leekId: number, weaponId: number, body?: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return LeekApiFp(this.configuration).leekAddWeaponPost(leekId, weaponId, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - create
     * @param {string} name 
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekCreatePost(name: string, body?: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return LeekApiFp(this.configuration).leekCreatePost(name, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - delete-register
     * @param {number} leekId 
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekDeleteRegisterDelete(leekId: number, key: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return LeekApiFp(this.configuration).leekDeleteRegisterDelete(leekId, key, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - get-count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekGetCountGet(options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return LeekApiFp(this.configuration).leekGetCountGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - get
     * @param {number} leekId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekGetGet(leekId: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return LeekApiFp(this.configuration).leekGetGet(leekId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - get-next-price
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekGetNextPriceGet(options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return LeekApiFp(this.configuration).leekGetNextPriceGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - get-private
     * @param {number} leekId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekGetPrivateGet(leekId: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return LeekApiFp(this.configuration).leekGetPrivateGet(leekId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - get-registers
     * @param {number} leekId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekGetRegistersGet(leekId: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return LeekApiFp(this.configuration).leekGetRegistersGet(leekId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - register-auto-br
     * @param {number} leekId 
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekRegisterAutoBrPost(leekId: number, body?: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return LeekApiFp(this.configuration).leekRegisterAutoBrPost(leekId, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - register-tournament
     * @param {number} leekId 
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekRegisterTournamentPost(leekId: number, body?: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return LeekApiFp(this.configuration).leekRegisterTournamentPost(leekId, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - remove-ai
     * @param {number} leekId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekRemoveAiDelete(leekId: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return LeekApiFp(this.configuration).leekRemoveAiDelete(leekId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - remove-chip
     * @param {number} chipId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekRemoveChipDelete(chipId: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return LeekApiFp(this.configuration).leekRemoveChipDelete(chipId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - remove-hat
     * @param {number} leekId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekRemoveHatDelete(leekId: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return LeekApiFp(this.configuration).leekRemoveHatDelete(leekId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - remove-weapon
     * @param {number} weaponId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekRemoveWeaponDelete(weaponId: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return LeekApiFp(this.configuration).leekRemoveWeaponDelete(weaponId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - rename-crystals
     * @param {number} leekId 
     * @param {string} newName 
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekRenameCrystalsPost(leekId: number, newName: string, body?: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return LeekApiFp(this.configuration).leekRenameCrystalsPost(leekId, newName, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - rename-habs
     * @param {number} leekId 
     * @param {string} newName 
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekRenameHabsPost(leekId: number, newName: string, body?: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return LeekApiFp(this.configuration).leekRenameHabsPost(leekId, newName, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - rich-tooltip
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekRichTooltipGet(id: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return LeekApiFp(this.configuration).leekRichTooltipGet(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - set-ai
     * @param {number} leekId 
     * @param {number} aiId 
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekSetAiPost(leekId: number, aiId: number, body?: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return LeekApiFp(this.configuration).leekSetAiPost(leekId, aiId, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - set-face
     * @param {number} leekId 
     * @param {number} face 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekSetFacePut(leekId: number, face: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return LeekApiFp(this.configuration).leekSetFacePut(leekId, face, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - set-hat
     * @param {number} leekId 
     * @param {number} hatId 
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekSetHatPost(leekId: number, hatId: number, body?: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return LeekApiFp(this.configuration).leekSetHatPost(leekId, hatId, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - set-in-garden
     * @param {number} leekId 
     * @param {boolean} inGarden 
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekSetInGardenPost(leekId: number, inGarden: boolean, body?: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return LeekApiFp(this.configuration).leekSetInGardenPost(leekId, inGarden, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - set-metal
     * @param {number} leekId 
     * @param {boolean} metal 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekSetMetalPut(leekId: number, metal: boolean, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return LeekApiFp(this.configuration).leekSetMetalPut(leekId, metal, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - set-register
     * @param {number} leekId 
     * @param {string} key 
     * @param {string} value 
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekSetRegisterPost(leekId: number, key: string, value: string, body?: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return LeekApiFp(this.configuration).leekSetRegisterPost(leekId, key, value, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - set-weapon
     * @param {number} leekId 
     * @param {number} weapon 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekSetWeaponPut(leekId: number, weapon: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return LeekApiFp(this.configuration).leekSetWeaponPut(leekId, weapon, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - set-xp-blocked
     * @param {number} leekId 
     * @param {boolean} xpBlocked 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekSetXpBlockedPut(leekId: number, xpBlocked: boolean, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return LeekApiFp(this.configuration).leekSetXpBlockedPut(leekId, xpBlocked, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - spend-capital
     * @param {number} leekId 
     * @param {string} characteristics 
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekSpendCapitalPost(leekId: number, characteristics: string, body?: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return LeekApiFp(this.configuration).leekSpendCapitalPost(leekId, characteristics, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - unregister-auto-br
     * @param {number} leekId 
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekUnregisterAutoBrPost(leekId: number, body?: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return LeekApiFp(this.configuration).leekUnregisterAutoBrPost(leekId, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - unregister-tournament
     * @param {number} leekId 
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekUnregisterTournamentPost(leekId: number, body?: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return LeekApiFp(this.configuration).leekUnregisterTournamentPost(leekId, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - use-potion
     * @param {number} leekId 
     * @param {number} potionId 
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekUsePotionPost(leekId: number, potionId: number, body?: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return LeekApiFp(this.configuration).leekUsePotionPost(leekId, potionId, body, options).then((request) => request(this.axios, this.basePath));
    }
}
