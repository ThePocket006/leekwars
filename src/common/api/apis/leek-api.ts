/* tslint:disable */
/* eslint-disable */
/**
 * Leekwars API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import type {AxiosInstance, AxiosRequestConfig, AxiosResponse} from "axios";
import globalAxios from "axios";
import { Configuration } from '@/common/api';
import type {RequestArgs} from "@/common/api/base";
import {BASE_PATH, BaseAPI, RequiredError} from "@/common/api/base";
/**
 * LeekApi - axios parameter creator
 * @export
 */
export const LeekApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary leek - add-chip
         * @param {number} leekId 
         * @param {number} chipId 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekAddChipPostForm: async (leekId: number, chipId: number, file?: Blob, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekAddChipPostForm.');
            }
            // verify required parameter 'chipId' is not null or undefined
            if (chipId === null || chipId === undefined) {
                throw new RequiredError('chipId','Required parameter chipId was null or undefined when calling leekAddChipPostForm.');
            }
            const localVarPath = `/leek/add-chip`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            if (chipId !== undefined) {
                localVarQueryParameter['chip_id'] = chipId;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - add-weapon
         * @param {number} leekId 
         * @param {number} weaponId 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekAddWeaponPostForm: async (leekId: number, weaponId: number, file?: Blob, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekAddWeaponPostForm.');
            }
            // verify required parameter 'weaponId' is not null or undefined
            if (weaponId === null || weaponId === undefined) {
                throw new RequiredError('weaponId','Required parameter weaponId was null or undefined when calling leekAddWeaponPostForm.');
            }
            const localVarPath = `/leek/add-weapon`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            if (weaponId !== undefined) {
                localVarQueryParameter['weapon_id'] = weaponId;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - create
         * @param {string} name 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekCreatePostForm: async (name: string, file?: Blob, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling leekCreatePostForm.');
            }
            const localVarPath = `/leek/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - delete-register
         * @param {number} leekId 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekDeleteRegisterDelete: async (leekId: number, key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekDeleteRegisterDelete.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling leekDeleteRegisterDelete.');
            }
            const localVarPath = `/leek/delete-register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - get-count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekGetCountGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/leek/get-count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - get
         * @param {number} leekId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekGetGet: async (leekId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekGetGet.');
            }
            const localVarPath = `/leek/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - get-next-price
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekGetNextPriceGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/leek/get-next-price`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - get-private
         * @param {number} leekId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekGetPrivateGet: async (leekId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekGetPrivateGet.');
            }
            const localVarPath = `/leek/get-private`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - get-registers
         * @param {number} leekId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekGetRegistersGet: async (leekId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekGetRegistersGet.');
            }
            const localVarPath = `/leek/get-registers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - register-auto-br
         * @param {number} leekId 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekRegisterAutoBrPostForm: async (leekId: number, file?: Blob, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekRegisterAutoBrPostForm.');
            }
            const localVarPath = `/leek/register-auto-br`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - register-tournament
         * @param {number} leekId 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekRegisterTournamentPostForm: async (leekId: number, file?: Blob, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekRegisterTournamentPostForm.');
            }
            const localVarPath = `/leek/register-tournament`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - remove-ai
         * @param {number} leekId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekRemoveAiDelete: async (leekId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekRemoveAiDelete.');
            }
            const localVarPath = `/leek/remove-ai`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - remove-chip
         * @param {number} chipId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekRemoveChipDelete: async (chipId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chipId' is not null or undefined
            if (chipId === null || chipId === undefined) {
                throw new RequiredError('chipId','Required parameter chipId was null or undefined when calling leekRemoveChipDelete.');
            }
            const localVarPath = `/leek/remove-chip`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (chipId !== undefined) {
                localVarQueryParameter['chip_id'] = chipId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - remove-hat
         * @param {number} leekId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekRemoveHatDelete: async (leekId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekRemoveHatDelete.');
            }
            const localVarPath = `/leek/remove-hat`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - remove-weapon
         * @param {number} weaponId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekRemoveWeaponDelete: async (weaponId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'weaponId' is not null or undefined
            if (weaponId === null || weaponId === undefined) {
                throw new RequiredError('weaponId','Required parameter weaponId was null or undefined when calling leekRemoveWeaponDelete.');
            }
            const localVarPath = `/leek/remove-weapon`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (weaponId !== undefined) {
                localVarQueryParameter['weapon_id'] = weaponId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - rename-crystals
         * @param {number} leekId 
         * @param {string} newName 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekRenameCrystalsPostForm: async (leekId: number, newName: string, file?: Blob, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekRenameCrystalsPostForm.');
            }
            // verify required parameter 'newName' is not null or undefined
            if (newName === null || newName === undefined) {
                throw new RequiredError('newName','Required parameter newName was null or undefined when calling leekRenameCrystalsPostForm.');
            }
            const localVarPath = `/leek/rename-crystals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            if (newName !== undefined) {
                localVarQueryParameter['new_name'] = newName;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - rename-habs
         * @param {number} leekId 
         * @param {string} newName 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekRenameHabsPostForm: async (leekId: number, newName: string, file?: Blob, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekRenameHabsPostForm.');
            }
            // verify required parameter 'newName' is not null or undefined
            if (newName === null || newName === undefined) {
                throw new RequiredError('newName','Required parameter newName was null or undefined when calling leekRenameHabsPostForm.');
            }
            const localVarPath = `/leek/rename-habs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            if (newName !== undefined) {
                localVarQueryParameter['new_name'] = newName;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - rich-tooltip
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekRichTooltipGet: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling leekRichTooltipGet.');
            }
            const localVarPath = `/leek/rich-tooltip`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - set-ai
         * @param {number} leekId 
         * @param {number} aiId 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekSetAiPostForm: async (leekId: number, aiId: number, file?: Blob, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekSetAiPostForm.');
            }
            // verify required parameter 'aiId' is not null or undefined
            if (aiId === null || aiId === undefined) {
                throw new RequiredError('aiId','Required parameter aiId was null or undefined when calling leekSetAiPostForm.');
            }
            const localVarPath = `/leek/set-ai`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            if (aiId !== undefined) {
                localVarQueryParameter['ai_id'] = aiId;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - set-face
         * @param {number} leekId 
         * @param {number} face 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekSetFacePut: async (leekId: number, face: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekSetFacePut.');
            }
            // verify required parameter 'face' is not null or undefined
            if (face === null || face === undefined) {
                throw new RequiredError('face','Required parameter face was null or undefined when calling leekSetFacePut.');
            }
            const localVarPath = `/leek/set-face`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            if (face !== undefined) {
                localVarQueryParameter['face'] = face;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - set-hat
         * @param {number} leekId 
         * @param {number} hatId 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekSetHatPostForm: async (leekId: number, hatId: number, file?: Blob, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekSetHatPostForm.');
            }
            // verify required parameter 'hatId' is not null or undefined
            if (hatId === null || hatId === undefined) {
                throw new RequiredError('hatId','Required parameter hatId was null or undefined when calling leekSetHatPostForm.');
            }
            const localVarPath = `/leek/set-hat`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            if (hatId !== undefined) {
                localVarQueryParameter['hat_id'] = hatId;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - set-in-garden
         * @param {number} leekId 
         * @param {boolean} inGarden 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekSetInGardenPostForm: async (leekId: number, inGarden: boolean, file?: Blob, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekSetInGardenPostForm.');
            }
            // verify required parameter 'inGarden' is not null or undefined
            if (inGarden === null || inGarden === undefined) {
                throw new RequiredError('inGarden','Required parameter inGarden was null or undefined when calling leekSetInGardenPostForm.');
            }
            const localVarPath = `/leek/set-in-garden`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            if (inGarden !== undefined) {
                localVarQueryParameter['in_garden'] = inGarden;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - set-metal
         * @param {number} leekId 
         * @param {boolean} metal 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekSetMetalPut: async (leekId: number, metal: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekSetMetalPut.');
            }
            // verify required parameter 'metal' is not null or undefined
            if (metal === null || metal === undefined) {
                throw new RequiredError('metal','Required parameter metal was null or undefined when calling leekSetMetalPut.');
            }
            const localVarPath = `/leek/set-metal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            if (metal !== undefined) {
                localVarQueryParameter['metal'] = metal;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - set-register
         * @param {number} leekId 
         * @param {string} key 
         * @param {string} value 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekSetRegisterPostForm: async (leekId: number, key: string, value: string, file?: Blob, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekSetRegisterPostForm.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling leekSetRegisterPostForm.');
            }
            // verify required parameter 'value' is not null or undefined
            if (value === null || value === undefined) {
                throw new RequiredError('value','Required parameter value was null or undefined when calling leekSetRegisterPostForm.');
            }
            const localVarPath = `/leek/set-register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - set-weapon
         * @param {number} leekId 
         * @param {number} weapon 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekSetWeaponPut: async (leekId: number, weapon: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekSetWeaponPut.');
            }
            // verify required parameter 'weapon' is not null or undefined
            if (weapon === null || weapon === undefined) {
                throw new RequiredError('weapon','Required parameter weapon was null or undefined when calling leekSetWeaponPut.');
            }
            const localVarPath = `/leek/set-weapon`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            if (weapon !== undefined) {
                localVarQueryParameter['weapon'] = weapon;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - set-xp-blocked
         * @param {number} leekId 
         * @param {boolean} xpBlocked 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekSetXpBlockedPut: async (leekId: number, xpBlocked: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekSetXpBlockedPut.');
            }
            // verify required parameter 'xpBlocked' is not null or undefined
            if (xpBlocked === null || xpBlocked === undefined) {
                throw new RequiredError('xpBlocked','Required parameter xpBlocked was null or undefined when calling leekSetXpBlockedPut.');
            }
            const localVarPath = `/leek/set-xp-blocked`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            if (xpBlocked !== undefined) {
                localVarQueryParameter['xp_blocked'] = xpBlocked;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - spend-capital
         * @param {number} leekId 
         * @param {string} characteristics 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekSpendCapitalPostForm: async (leekId: number, characteristics: string, file?: Blob, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekSpendCapitalPostForm.');
            }
            // verify required parameter 'characteristics' is not null or undefined
            if (characteristics === null || characteristics === undefined) {
                throw new RequiredError('characteristics','Required parameter characteristics was null or undefined when calling leekSpendCapitalPostForm.');
            }
            const localVarPath = `/leek/spend-capital`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            if (characteristics !== undefined) {
                localVarQueryParameter['characteristics'] = characteristics;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - unregister-auto-br
         * @param {number} leekId 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekUnregisterAutoBrPostForm: async (leekId: number, file?: Blob, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekUnregisterAutoBrPostForm.');
            }
            const localVarPath = `/leek/unregister-auto-br`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - unregister-tournament
         * @param {number} leekId 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekUnregisterTournamentPostForm: async (leekId: number, file?: Blob, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekUnregisterTournamentPostForm.');
            }
            const localVarPath = `/leek/unregister-tournament`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary leek - use-potion
         * @param {number} leekId 
         * @param {number} potionId 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leekUsePotionPostForm: async (leekId: number, potionId: number, file?: Blob, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leekId' is not null or undefined
            if (leekId === null || leekId === undefined) {
                throw new RequiredError('leekId','Required parameter leekId was null or undefined when calling leekUsePotionPostForm.');
            }
            // verify required parameter 'potionId' is not null or undefined
            if (potionId === null || potionId === undefined) {
                throw new RequiredError('potionId','Required parameter potionId was null or undefined when calling leekUsePotionPostForm.');
            }
            const localVarPath = `/leek/use-potion`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication bearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (leekId !== undefined) {
                localVarQueryParameter['leek_id'] = leekId;
            }

            if (potionId !== undefined) {
                localVarQueryParameter['potion_id'] = potionId;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LeekApi - functional programming interface
 * @export
 */
export const LeekApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary leek - add-chip
         * @param {number} leekId 
         * @param {number} chipId 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekAddChipPostForm(leekId: number, chipId: number, file?: Blob, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekAddChipPostForm(leekId, chipId, file, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - add-weapon
         * @param {number} leekId 
         * @param {number} weaponId 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekAddWeaponPostForm(leekId: number, weaponId: number, file?: Blob, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekAddWeaponPostForm(leekId, weaponId, file, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - create
         * @param {string} name 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekCreatePostForm(name: string, file?: Blob, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekCreatePostForm(name, file, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - delete-register
         * @param {number} leekId 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekDeleteRegisterDelete(leekId: number, key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekDeleteRegisterDelete(leekId, key, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - get-count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekGetCountGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekGetCountGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - get
         * @param {number} leekId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekGetGet(leekId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekGetGet(leekId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - get-next-price
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekGetNextPriceGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekGetNextPriceGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - get-private
         * @param {number} leekId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekGetPrivateGet(leekId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekGetPrivateGet(leekId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - get-registers
         * @param {number} leekId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekGetRegistersGet(leekId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekGetRegistersGet(leekId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - register-auto-br
         * @param {number} leekId 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekRegisterAutoBrPostForm(leekId: number, file?: Blob, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekRegisterAutoBrPostForm(leekId, file, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - register-tournament
         * @param {number} leekId 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekRegisterTournamentPostForm(leekId: number, file?: Blob, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekRegisterTournamentPostForm(leekId, file, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - remove-ai
         * @param {number} leekId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekRemoveAiDelete(leekId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekRemoveAiDelete(leekId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - remove-chip
         * @param {number} chipId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekRemoveChipDelete(chipId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekRemoveChipDelete(chipId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - remove-hat
         * @param {number} leekId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekRemoveHatDelete(leekId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekRemoveHatDelete(leekId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - remove-weapon
         * @param {number} weaponId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekRemoveWeaponDelete(weaponId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekRemoveWeaponDelete(weaponId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - rename-crystals
         * @param {number} leekId 
         * @param {string} newName 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekRenameCrystalsPostForm(leekId: number, newName: string, file?: Blob, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekRenameCrystalsPostForm(leekId, newName, file, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - rename-habs
         * @param {number} leekId 
         * @param {string} newName 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekRenameHabsPostForm(leekId: number, newName: string, file?: Blob, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekRenameHabsPostForm(leekId, newName, file, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - rich-tooltip
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekRichTooltipGet(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekRichTooltipGet(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - set-ai
         * @param {number} leekId 
         * @param {number} aiId 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekSetAiPostForm(leekId: number, aiId: number, file?: Blob, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekSetAiPostForm(leekId, aiId, file, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - set-face
         * @param {number} leekId 
         * @param {number} face 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekSetFacePut(leekId: number, face: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekSetFacePut(leekId, face, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - set-hat
         * @param {number} leekId 
         * @param {number} hatId 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekSetHatPostForm(leekId: number, hatId: number, file?: Blob, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekSetHatPostForm(leekId, hatId, file, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - set-in-garden
         * @param {number} leekId 
         * @param {boolean} inGarden 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekSetInGardenPostForm(leekId: number, inGarden: boolean, file?: Blob, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekSetInGardenPostForm(leekId, inGarden, file, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - set-metal
         * @param {number} leekId 
         * @param {boolean} metal 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekSetMetalPut(leekId: number, metal: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekSetMetalPut(leekId, metal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - set-register
         * @param {number} leekId 
         * @param {string} key 
         * @param {string} value 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekSetRegisterPostForm(leekId: number, key: string, value: string, file?: Blob, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekSetRegisterPostForm(leekId, key, value, file, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - set-weapon
         * @param {number} leekId 
         * @param {number} weapon 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekSetWeaponPut(leekId: number, weapon: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekSetWeaponPut(leekId, weapon, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - set-xp-blocked
         * @param {number} leekId 
         * @param {boolean} xpBlocked 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekSetXpBlockedPut(leekId: number, xpBlocked: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekSetXpBlockedPut(leekId, xpBlocked, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - spend-capital
         * @param {number} leekId 
         * @param {string} characteristics 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekSpendCapitalPostForm(leekId: number, characteristics: string, file?: Blob, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekSpendCapitalPostForm(leekId, characteristics, file, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - unregister-auto-br
         * @param {number} leekId 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekUnregisterAutoBrPostForm(leekId: number, file?: Blob, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekUnregisterAutoBrPostForm(leekId, file, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - unregister-tournament
         * @param {number} leekId 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekUnregisterTournamentPostForm(leekId: number, file?: Blob, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekUnregisterTournamentPostForm(leekId, file, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary leek - use-potion
         * @param {number} leekId 
         * @param {number} potionId 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekUsePotionPostForm(leekId: number, potionId: number, file?: Blob, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await LeekApiAxiosParamCreator(configuration).leekUsePotionPostForm(leekId, potionId, file, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LeekApi - factory interface
 * @export
 */
export const LeekApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary leek - add-chip
         * @param {number} leekId 
         * @param {number} chipId 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekAddChipPostForm(leekId: number, chipId: number, file?: Blob, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return LeekApiFp(configuration).leekAddChipPostForm(leekId, chipId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - add-weapon
         * @param {number} leekId 
         * @param {number} weaponId 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekAddWeaponPostForm(leekId: number, weaponId: number, file?: Blob, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return LeekApiFp(configuration).leekAddWeaponPostForm(leekId, weaponId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - create
         * @param {string} name 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekCreatePostForm(name: string, file?: Blob, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return LeekApiFp(configuration).leekCreatePostForm(name, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - delete-register
         * @param {number} leekId 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekDeleteRegisterDelete(leekId: number, key: string, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return LeekApiFp(configuration).leekDeleteRegisterDelete(leekId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - get-count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekGetCountGet(options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return LeekApiFp(configuration).leekGetCountGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - get
         * @param {number} leekId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekGetGet(leekId: number, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return LeekApiFp(configuration).leekGetGet(leekId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - get-next-price
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekGetNextPriceGet(options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return LeekApiFp(configuration).leekGetNextPriceGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - get-private
         * @param {number} leekId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekGetPrivateGet(leekId: number, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return LeekApiFp(configuration).leekGetPrivateGet(leekId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - get-registers
         * @param {number} leekId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekGetRegistersGet(leekId: number, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return LeekApiFp(configuration).leekGetRegistersGet(leekId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - register-auto-br
         * @param {number} leekId 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekRegisterAutoBrPostForm(leekId: number, file?: Blob, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return LeekApiFp(configuration).leekRegisterAutoBrPostForm(leekId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - register-tournament
         * @param {number} leekId 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekRegisterTournamentPostForm(leekId: number, file?: Blob, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return LeekApiFp(configuration).leekRegisterTournamentPostForm(leekId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - remove-ai
         * @param {number} leekId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekRemoveAiDelete(leekId: number, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return LeekApiFp(configuration).leekRemoveAiDelete(leekId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - remove-chip
         * @param {number} chipId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekRemoveChipDelete(chipId: number, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return LeekApiFp(configuration).leekRemoveChipDelete(chipId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - remove-hat
         * @param {number} leekId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekRemoveHatDelete(leekId: number, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return LeekApiFp(configuration).leekRemoveHatDelete(leekId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - remove-weapon
         * @param {number} weaponId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekRemoveWeaponDelete(weaponId: number, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return LeekApiFp(configuration).leekRemoveWeaponDelete(weaponId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - rename-crystals
         * @param {number} leekId 
         * @param {string} newName 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekRenameCrystalsPostForm(leekId: number, newName: string, file?: Blob, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return LeekApiFp(configuration).leekRenameCrystalsPostForm(leekId, newName, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - rename-habs
         * @param {number} leekId 
         * @param {string} newName 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekRenameHabsPostForm(leekId: number, newName: string, file?: Blob, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return LeekApiFp(configuration).leekRenameHabsPostForm(leekId, newName, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - rich-tooltip
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekRichTooltipGet(id: number, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return LeekApiFp(configuration).leekRichTooltipGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - set-ai
         * @param {number} leekId 
         * @param {number} aiId 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekSetAiPostForm(leekId: number, aiId: number, file?: Blob, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return LeekApiFp(configuration).leekSetAiPostForm(leekId, aiId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - set-face
         * @param {number} leekId 
         * @param {number} face 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekSetFacePut(leekId: number, face: number, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return LeekApiFp(configuration).leekSetFacePut(leekId, face, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - set-hat
         * @param {number} leekId 
         * @param {number} hatId 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekSetHatPostForm(leekId: number, hatId: number, file?: Blob, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return LeekApiFp(configuration).leekSetHatPostForm(leekId, hatId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - set-in-garden
         * @param {number} leekId 
         * @param {boolean} inGarden 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekSetInGardenPostForm(leekId: number, inGarden: boolean, file?: Blob, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return LeekApiFp(configuration).leekSetInGardenPostForm(leekId, inGarden, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - set-metal
         * @param {number} leekId 
         * @param {boolean} metal 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekSetMetalPut(leekId: number, metal: boolean, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return LeekApiFp(configuration).leekSetMetalPut(leekId, metal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - set-register
         * @param {number} leekId 
         * @param {string} key 
         * @param {string} value 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekSetRegisterPostForm(leekId: number, key: string, value: string, file?: Blob, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return LeekApiFp(configuration).leekSetRegisterPostForm(leekId, key, value, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - set-weapon
         * @param {number} leekId 
         * @param {number} weapon 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekSetWeaponPut(leekId: number, weapon: number, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return LeekApiFp(configuration).leekSetWeaponPut(leekId, weapon, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - set-xp-blocked
         * @param {number} leekId 
         * @param {boolean} xpBlocked 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekSetXpBlockedPut(leekId: number, xpBlocked: boolean, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return LeekApiFp(configuration).leekSetXpBlockedPut(leekId, xpBlocked, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - spend-capital
         * @param {number} leekId 
         * @param {string} characteristics 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekSpendCapitalPostForm(leekId: number, characteristics: string, file?: Blob, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return LeekApiFp(configuration).leekSpendCapitalPostForm(leekId, characteristics, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - unregister-auto-br
         * @param {number} leekId 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekUnregisterAutoBrPostForm(leekId: number, file?: Blob, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return LeekApiFp(configuration).leekUnregisterAutoBrPostForm(leekId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - unregister-tournament
         * @param {number} leekId 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekUnregisterTournamentPostForm(leekId: number, file?: Blob, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return LeekApiFp(configuration).leekUnregisterTournamentPostForm(leekId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary leek - use-potion
         * @param {number} leekId 
         * @param {number} potionId 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leekUsePotionPostForm(leekId: number, potionId: number, file?: Blob, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return LeekApiFp(configuration).leekUsePotionPostForm(leekId, potionId, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LeekApi - object-oriented interface
 * @export
 * @class LeekApi
 * @extends {BaseAPI}
 */
export class LeekApi extends BaseAPI {
    /**
     * 
     * @summary leek - add-chip
     * @param {number} leekId 
     * @param {number} chipId 
     * @param {Blob} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekAddChipPostForm(leekId: number, chipId: number, file?: Blob, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return LeekApiFp(this.configuration).leekAddChipPostForm(leekId, chipId, file, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - add-weapon
     * @param {number} leekId 
     * @param {number} weaponId 
     * @param {Blob} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekAddWeaponPostForm(leekId: number, weaponId: number, file?: Blob, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return LeekApiFp(this.configuration).leekAddWeaponPostForm(leekId, weaponId, file, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - create
     * @param {string} name 
     * @param {Blob} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekCreatePostForm(name: string, file?: Blob, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return LeekApiFp(this.configuration).leekCreatePostForm(name, file, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - delete-register
     * @param {number} leekId 
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekDeleteRegisterDelete(leekId: number, key: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return LeekApiFp(this.configuration).leekDeleteRegisterDelete(leekId, key, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - get-count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekGetCountGet(options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return LeekApiFp(this.configuration).leekGetCountGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - get
     * @param {number} leekId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekGetGet(leekId: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return LeekApiFp(this.configuration).leekGetGet(leekId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - get-next-price
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekGetNextPriceGet(options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return LeekApiFp(this.configuration).leekGetNextPriceGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - get-private
     * @param {number} leekId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekGetPrivateGet(leekId: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return LeekApiFp(this.configuration).leekGetPrivateGet(leekId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - get-registers
     * @param {number} leekId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekGetRegistersGet(leekId: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return LeekApiFp(this.configuration).leekGetRegistersGet(leekId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - register-auto-br
     * @param {number} leekId 
     * @param {Blob} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekRegisterAutoBrPostForm(leekId: number, file?: Blob, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return LeekApiFp(this.configuration).leekRegisterAutoBrPostForm(leekId, file, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - register-tournament
     * @param {number} leekId 
     * @param {Blob} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekRegisterTournamentPostForm(leekId: number, file?: Blob, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return LeekApiFp(this.configuration).leekRegisterTournamentPostForm(leekId, file, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - remove-ai
     * @param {number} leekId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekRemoveAiDelete(leekId: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return LeekApiFp(this.configuration).leekRemoveAiDelete(leekId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - remove-chip
     * @param {number} chipId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekRemoveChipDelete(chipId: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return LeekApiFp(this.configuration).leekRemoveChipDelete(chipId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - remove-hat
     * @param {number} leekId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekRemoveHatDelete(leekId: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return LeekApiFp(this.configuration).leekRemoveHatDelete(leekId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - remove-weapon
     * @param {number} weaponId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekRemoveWeaponDelete(weaponId: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return LeekApiFp(this.configuration).leekRemoveWeaponDelete(weaponId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - rename-crystals
     * @param {number} leekId 
     * @param {string} newName 
     * @param {Blob} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekRenameCrystalsPostForm(leekId: number, newName: string, file?: Blob, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return LeekApiFp(this.configuration).leekRenameCrystalsPostForm(leekId, newName, file, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - rename-habs
     * @param {number} leekId 
     * @param {string} newName 
     * @param {Blob} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekRenameHabsPostForm(leekId: number, newName: string, file?: Blob, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return LeekApiFp(this.configuration).leekRenameHabsPostForm(leekId, newName, file, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - rich-tooltip
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekRichTooltipGet(id: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return LeekApiFp(this.configuration).leekRichTooltipGet(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - set-ai
     * @param {number} leekId 
     * @param {number} aiId 
     * @param {Blob} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekSetAiPostForm(leekId: number, aiId: number, file?: Blob, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return LeekApiFp(this.configuration).leekSetAiPostForm(leekId, aiId, file, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - set-face
     * @param {number} leekId 
     * @param {number} face 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekSetFacePut(leekId: number, face: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return LeekApiFp(this.configuration).leekSetFacePut(leekId, face, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - set-hat
     * @param {number} leekId 
     * @param {number} hatId 
     * @param {Blob} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekSetHatPostForm(leekId: number, hatId: number, file?: Blob, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return LeekApiFp(this.configuration).leekSetHatPostForm(leekId, hatId, file, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - set-in-garden
     * @param {number} leekId 
     * @param {boolean} inGarden 
     * @param {Blob} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekSetInGardenPostForm(leekId: number, inGarden: boolean, file?: Blob, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return LeekApiFp(this.configuration).leekSetInGardenPostForm(leekId, inGarden, file, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - set-metal
     * @param {number} leekId 
     * @param {boolean} metal 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekSetMetalPut(leekId: number, metal: boolean, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return LeekApiFp(this.configuration).leekSetMetalPut(leekId, metal, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - set-register
     * @param {number} leekId 
     * @param {string} key 
     * @param {string} value 
     * @param {Blob} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekSetRegisterPostForm(leekId: number, key: string, value: string, file?: Blob, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return LeekApiFp(this.configuration).leekSetRegisterPostForm(leekId, key, value, file, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - set-weapon
     * @param {number} leekId 
     * @param {number} weapon 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekSetWeaponPut(leekId: number, weapon: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return LeekApiFp(this.configuration).leekSetWeaponPut(leekId, weapon, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - set-xp-blocked
     * @param {number} leekId 
     * @param {boolean} xpBlocked 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekSetXpBlockedPut(leekId: number, xpBlocked: boolean, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return LeekApiFp(this.configuration).leekSetXpBlockedPut(leekId, xpBlocked, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - spend-capital
     * @param {number} leekId 
     * @param {string} characteristics 
     * @param {Blob} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekSpendCapitalPostForm(leekId: number, characteristics: string, file?: Blob, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return LeekApiFp(this.configuration).leekSpendCapitalPostForm(leekId, characteristics, file, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - unregister-auto-br
     * @param {number} leekId 
     * @param {Blob} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekUnregisterAutoBrPostForm(leekId: number, file?: Blob, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return LeekApiFp(this.configuration).leekUnregisterAutoBrPostForm(leekId, file, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - unregister-tournament
     * @param {number} leekId 
     * @param {Blob} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekUnregisterTournamentPostForm(leekId: number, file?: Blob, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return LeekApiFp(this.configuration).leekUnregisterTournamentPostForm(leekId, file, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary leek - use-potion
     * @param {number} leekId 
     * @param {number} potionId 
     * @param {Blob} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeekApi
     */
    public async leekUsePotionPostForm(leekId: number, potionId: number, file?: Blob, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return LeekApiFp(this.configuration).leekUsePotionPostForm(leekId, potionId, file, options).then((request) => request(this.axios, this.basePath));
    }
}
